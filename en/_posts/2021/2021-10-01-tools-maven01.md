---
category: tools
excerpt: From Importing Dependencies to Packaging
keywords: tools, java
lang: en
layout: post
title: Understanding the Maven Lifecycle from IntelliJ IDEA‚Äôs Perspective
---

## Preface

Recently I was chatting tech with some friends, and I realized a lot of people don‚Äôt really know what all the commands in the Maven panel on the right side of IDEA mean. Some people have literally never even opened it, let alone used `clean`. Some don‚Äôt know `install` either. That honestly surprised me... so I‚Äôm trying to summarize it in a way that (I think) is easy to understand. Later I can even use this as a ‚Äúfiller‚Äù for an internal tech sharing session üòã

![image-20210930205154357](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20210930205154.png)

<center>Maven control panel on the right side of IDEA</center>

## Maven Overview

Simply put, Maven has two important jobs

####  Packaging

Java is often called a semi-interpreted language. On one hand, Java has a pre-compilation process: you need to turn `.java` into `.class` and run it on the JVM, and then `.class` is interpreted and executed on the JVM. Java provides `javac` to compile Java files, but with *so many* `.java` files, you still need a tool to help you package everything in a unified way. Maven can do that for us‚Äîjust use `maven compiler` and it can compile the entire project.

![image-20210930231847300](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20210930231847.png)

<center>Native Java compilation</center>



#### Dependency management

When you‚Äôre coding, most of the time you‚Äôre either copy-pasting code (cmd+c / cmd+v) or looking for ‚Äúwheels‚Äù on GitHub. Copy-pasting is easy, but integrating a wheel into your project means downloading the jar, adding it into some directory you created, finding and downloading everything yourself, and managing it yourself. Maven can handle this really well: with just a `pom` file you can import all kinds of dependencies and also do a lot of project configuration.

![image-20210930232738343](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20210930232738.png)

<center>Jar management at the beginning, without Maven</center>

Most importantly, if you use Maven, packaging and dependency management can be perfectly combined‚Äîso when you package project B, you can pull in the artifact packaged from project A.



## Dependency Coordinates

Here I‚Äôm assuming you‚Äôve already used Maven before, so you naturally know Maven‚Äôs dependency coordinate rules:

```xml
<dependency>
    <!-- Package name; in the local repository, folders are organized based on this -->
    <groupId>cn.hutool</groupId>
    <!-- The specific dependency name -->
    <artifactId>hutool-all</artifactId>
    <!-- Version number -->
    <version>5.6.5</version>
</dependency>
```

All Maven dependencies are actually stored in the cloud. Maven officially has a place called the **Central Repository**, and by default it will fetch from there. Of course, you can also set up your own **private repository** (companies usually have an internal one), and configure Maven to prefer pulling from the private repo first. Downloaded artifacts are stored locally as the **local repository**. All of this is configurable, including Central repo mirrors, private repo addresses, local repo paths, etc.

The priority is: first check whether the dependency exists in the local repository (based on the `groupId` path + `artifactId` name). If it doesn‚Äôt exist, then fetch it from the Central Repository, and after fetching, store it into the local repository.



## Lifecycle

After that, these build lifecycle commands are pretty easy to explain.

| Command | Explanation |
| ------- | ----------- |
| clean   | Runs a cleanup (by default it cleans data in the `target` folder) |
| compile | Compiles and outputs compiled code into the `target` folder |
| test    | Runs tests via a unit test framework (e.g., JUnit) (I usually disable this) |
| package | Creates a JAR/WAR as defined in `pom.xml` |
| install | Installs the packaged artifact into the local repository so other projects can use it |
| deploy  | Copies the final artifact to a remote repository to share with other developers/projects |

The ones used most often are `clean` / `compile` / `package` / `install`. Below I‚Äôll demonstrate using IDEA‚Äôs Maven plugin, but you can also use Maven‚Äôs native commands in the terminal, e.g. `mvn clean`.

#### Clean

This one is super simple. When I run into a bug I can‚Äôt solve, I‚Äôll just `clean` üòÇ. Basically it deletes the entire `target` folder (`target` is where Maven puts compiled outputs), which forces a recompilation so IDEA can ‚Äúeat‚Äù the latest code.

![2021-10-01 00.03.45](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211001000455.gif)

#### compile

This is kind of the opposite of the above. The above deletes the `target` folder; this generates it. I usually use this command to... check whether my code can compile. Before pushing code to Git, I‚Äôll typically run it once to avoid committing code that doesn‚Äôt even pass compilation.

![2021-10-02 13.22.51](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211002132630.gif)

#### package

I‚Äôm sure everyone uses this a lot. Even if you don‚Äôt package locally, you‚Äôll see Maven commands like this in CI/CD tools: `mvn package -Dmaven.test.skip=true -P prod`‚Äîthat‚Äôs packaging for the production environment. After you click package, it will first compile the current project, then package the compiled code into a jar (of course you can configure the packaging format in the `pom` file).

![2021-10-02 13.25.59](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211002132659.gif)

#### install

If you provide components for your team inside the company, you‚Äôll usually package your project into a jar and let other colleagues use it in their own projects. Or if you have two projects yourself and they‚Äôre not in the same workspace, and project B depends on project A, then for local testing/debugging you should use `install` to install project A into the local repository for debugging.

1. First, we create a `demo02` and specify `groupId` and `artifactId`

   ![image-20211002133710611](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211002133710.png)

2. Let‚Äôs check our local repository to see whether there is a nested folder path for `cn.someget.maven`

   ![image-20211002134153588](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211002134153.png)

<center>Confirmed it doesn‚Äôt exist</center>

3. In the `pom` file of another project, add a dependency on this project via `groupId` (note: it can‚Äôt be in the same project; within the same project Maven will detect it by default)

   ![image-20211002134505630](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211002134505.png)

<center>Just opened a random project... you can see an error, the import didn‚Äôt succeed</center>

4. Then we run `install` on the project and see what happens. As shown below, the dependency import no longer errors out. In the local repository, you can also see the jar we just built placed under `cn/someget/maven/<version>`.

![2021-10-02 13.46.30](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211002134920.gif)



## Afterword

Originally I wanted to put a project on GitHub too, but the National Day holiday was just too fun, so I only wrote a simple post. What I mainly want to express is the concept of Maven‚Äôs project build lifecycle. Except for `clean`, the other phases are layered/stacked step by step. For example, if I run `package`, I‚Äôll run `compiler` first; if I run `install`, I‚Äôll run `compiler` and then `package`. You can try it yourself: `clean` first, then directly `install`, and check whether there‚Äôs a `target` folder, whether there‚Äôs a jar inside it, and whether the local repository has the `groupId` path.