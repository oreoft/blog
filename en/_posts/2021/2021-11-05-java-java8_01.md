---
category: java
excerpt: A Quick Review of Functional Interfaces
keywords: java
lang: en
layout: post
title: Java 8 Functional Programming (Part 1)
---

## Preface

JDK 8 was released back in 2014 as an official version. Since it‚Äôs an LTS release and is still being maintained and updated, most companies that ‚Äúpin‚Äù their Java version are basically pinning to 8. But recently the long-term support release JDK 17 is also out, and later there might be more aggressive teams following up. A friend‚Äôs company has even put upgrading to JDK 17 on their evaluation roadmap‚Äîjealous, jealous. Back to JDK 8: I think the biggest highlight is that it let Java put one foot into the world of multi-paradigm programming languages.

Of course you‚Äôll definitely say ‚Äúcome on, that‚Äôs nothing,‚Äù it‚Äôs all just syntactic sugar. But paired with some great libraries, that‚Äôs exactly what I want to introduce: a Java functional library. I accidentally saw it on GitHub last time, went through the docs, learned it, and then brought it into my own project. It really can make you so sweet you just shut up‚Äîwriting feels like Scala. The library is called vavr, and here‚Äôs the [GitHub link](https://github.com/vavr-io/vavr)

So I want to introduce vavr: first, so I can summarize it for myself; second, to do a bit of evangelizing for you who also like things sweet. This post is the first part. To introduce vavr better, this one mainly covers functional programming in Java 8, and the detailed vavr introduction will be in the next part.



## Functional Programming

To do functional programming, you first need functions. Before Java 8, Java really only had the concept of methods‚Äîthere basically wasn‚Äôt a ‚Äúfunction‚Äù concept. Second, functions need to be ‚Äúfirst-class citizens.‚Äù By first-class citizen, I mean functions are on the same level as other primitive/reference types: they can be assigned, and they can be passed as parameters.

Java actually achieves this through an interface plus special lambda syntax. Here‚Äôs the lambda syntax:

```java
// ÂâçÈù¢ÊòØÂÖ•ÂèÇÔºåÁÑ∂Âêé‰∏≠Èó¥‰ΩøÁî®‰∏Ä‰∏™ ‚Äú->‚Äù ÁöÑÁ¨¶Âè∑ËøûÊé•, ÂêéÈù¢ÊòØË°®ËææÂºè
Type var -> Ë°®ËææÂºè;
/*
‰∏§‰∏™ÂÖ•ÂèÇÂâçÈù¢ÈúÄË¶ÅÊã¨Âè∑Êã¨Ëµ∑Êù•(‰∏Ä‰∏™‰πüÂèØ‰ª•Êã¨Âè∑Ôºå‰ΩÜÊòØÈÄöÂ∏∏ÁúÅÁï•)
Â¶ÇÊûúË°®ËææÂºèÂæàÂ§çÊùÇÔºå‰∏ÄÂè•ÂÜô‰∏çÂÆåÔºåÂàôÈúÄË¶Å‰ΩøÁî®{}Êã¨Ëµ∑Êù•ÔºåÂ¶ÇÊûúÊúâËøîÂõûÂÄºËøòÈúÄË¶ÅÂπ∂‰∏îÊâãÂä®return
*/
(Type1 var1, Type2 var2) -> {
  Ë°®ËææÂºè1;
  Ë°®ËææÂºè2;
}
// Â¶ÇÊûúÂáΩÊï∞Ê≤°ÊúâÂÖ•ÂèÇÔºåÂàôÂøÖÈ°ªË¶ÅÊã¨Âè∑Ôºå‰ΩÜÊòØÊã¨Âè∑ÈáåÈù¢‰ªÄ‰πàÈÉΩ‰∏çxei
() -> Ë°®ËææÂºè;

// Âè¶Â§ñÁ±ªÂûãjava‰ºöËá™Âä®Êé®Êñ≠ÔºåÂÖ∂ÂÆûÂÖ•ÂèÇÁöÑÁ±ªÂûãÂèØ‰ª•‰∏çÂÜôÔºåÂè™ÈúÄË¶ÅÂèñ‰∏™ÂêçÂ≠óÂ∞±Â•Ω‰∫Ü
var -> Ë°®ËææÂºè;
(var1, var2) -> Ë°®ËææÂºè
```

*Here are some real examples*

```java
// Âè™Êúâ‰∏Ä‰∏™ÂèÇÊï∞ÁöÑËØ≠Ê≥ï(Êã¨Âè∑ÁúÅÁï•ÔºåÁ±ªÂûã‰πüÁúÅÁï•)
str -> System.out.print(str);
str -> System.out.print(str);

// ‰∏§‰∏™ÂèÇÊï∞ÁöÑ‰æãÂ≠ê(‰∏§‰∏™ÂèÇÊï∞ÂøÖÈ°ªË¶ÅÊã¨Âè∑)
(str1, str2) -> System.out.print(str + str2);

// Ê≤°ÊúâÂÖ•ÂèÇÔºåÂ§çÊùÇË°®ËææÂºèÔºåËøòÂ∏¶ËøîÂõûÂÄº
() -> {
      String someget = new String("someget");
      String result = someget.concat(".cn");
      return result;
    };
  
```

A function written as a lambda can be assigned to an interface, and then you can pass inputs and outputs through that interface. Java itself is already huge; now it ships two major releases a year, but no matter how it changes, the syntax won‚Äôt undergo a massive upheaval. Some people say lambda is syntactic sugar for anonymous inner classes‚Äîit kind of smells like that, but calling it ‚Äúsyntactic sugar‚Äù isn‚Äôt accurate. After compiling a lambda, there isn‚Äôt a separate `.calss` bytecode file; the corresponding bytecode is generated at runtime.

p.s. One thing to note: lambda expressions in Java 8 are not full closures, because they only close over values, not variables. That is, variables used inside a lambda must be declared `final` or be implicitly `final` (meaning they‚Äôre not explicitly `final`, but they are never modified in the code). This also shows up in the immutable data structures in the next post, because this restriction makes your code insanely safe.

## Functional Interfaces

Above I introduced how Java implements functional programming. Java defines functions through interfaces: after you define a lambda, you can assign it to an interface, which means your lambda is actually implementing one method in that interface.

You can define this interface yourself‚Äîjust define one unimplemented (abstract) method. Note this is a hard requirement: the interface must have exactly one unimplemented (abstract) method. Java 8 introduced `default` methods in interfaces, and having `default` methods does not prevent it from being a functional interface. To let you check whether it meets the spec before compilation, Java 8 added the `@FunctionalInterface` annotation. With this annotation, the compiler knows you intend to write a functional interface, so if your interface doesn‚Äôt have an unimplemented method, it won‚Äôt compile. Functional interfaces are also called SAM interfaces, short for Single Abstract Method interfaces.

So if writing an interface with one unimplemented method can accept a lambda, and everyone‚Äôs method is unimplemented anyway, aren‚Äôt your interface and my interface the same? Yes and no. The method is indeed unimplemented, but the input and output types of each method are different. So the difference between functional interfaces is actually defined by the input and output of that single abstract method.

In theory, functional interfaces with the same input and output are the same. Java 8 has many built-in functional interfaces. Next I‚Äôll introduce the four most common ones‚Äîyou definitely use them a lot.

#### Function<T, R>

The official doc says it ‚Äúaccepts one argument and produces a result.‚Äù The name of this functional interface is slightly misleading because it‚Äôs literally called ‚ÄúFunction.‚Äù What it actually does is accept an object (generic `T`) and convert it into another object (generic `R`). In `Function<T, R>`, the first type parameter is the input generic, and the second is the output generic.

![image-20211115221406511](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211115221406.png)

<center>Source code</center>

As you can see, its unimplemented method is `apply`. If you‚Äôve used Java Stream or Scala‚Äôs `map` operator, you‚Äôll definitely be familiar with it: it **maps** each element in the stream into another type you want.

![image-20211115221604580](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211115221604.png)



#### Consumer<T> 

The official doc says it ‚Äúaccepts a single input argument and returns no result.‚Äù In other words, it only accepts one generic type and returns nothing (`void`). You can use side effects to accompany some expected state change or event.

![image-20211115222127716](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211115222127.png)

<center>Consumer source code</center>

The unimplemented method of `Consumer` is `accept`. It takes an object and returns `void`. The most commonly used `forEach` uses this interface.

![image-20211115222339830](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211115222339.png)



#### Predicate<T>

This functional interface takes in a type, but returns a boolean value (`true` or `false`). Also, quick rant: some books translate `predicate` as ‚ÄúË∞ìËØç‚Äù‚Äîthat‚Äôs seriously anti-human.

![image-20211115222654674](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211115222654.png)

<center>Source snippet</center>

Its unimplemented method is `test`. Smart you probably already thought of it: what you pass into `filter` in Java Stream is exactly this interface.

![image-20211115223230651](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211115223230.png)



#### Supplier<T>

The last commonly used one is a bit similar to `Consumer`, but reversed: it has no input parameters, but it has a return value.

![image-20211115223401921](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211115223401.png)

<center>Source snippet</center>

Its unimplemented method is `get`. If you‚Äôve written `() -> xxxx`, you should immediately react to this. For example, `supplyAsync` in `CompletableFuture` takes a `supplier`.

![image-20211115223511662](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211115223511.png)

Finally, let‚Äôs summarize these four most common functional interfaces. Writing them separately above is a bit messy, so here‚Äôs a table to memorize them together:

| Interface Name     | Chinese | Purpose                                                                 | Abstract Method     |
| ------------------ | ------- | ----------------------------------------------------------------------- | ------------------- |
| consumer<T>        | Ê∂àË¥πËÄÖ  | `T` is input; accepts a type and produces side effects                  | void accept(T t)    |
| function <T, R>    | ÂáΩÊï∞    | `T` is input, `R` is output; accepts a `T` and returns an `R` object    | R apply(T t)        |
| predicate<T>       | Êñ≠Ë®Ä    | `T` is input; accepts a `T` and returns a boolean value                 | boolean test(T t)   |
| supplier<T>        | Êèê‰æõËÄÖ  | `T` is output; no input (written as `() -> xxx`), returns a `T` object  | T get()             |

![image-20211115233015255](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20211115233015.png)

<center>A screenshot from the holy book ‚ÄúJava 8 in Action‚Äù</center>



## Afterword

I didn‚Äôt say a single word about vavr here. This is mainly a summary of Java‚Äôs functional programming interfaces. Of course I only listed four‚Äîthere are actually many more, like adding a `Binary` prefix and it becomes another functional interface (go check the source code). If the built-in ones aren‚Äôt enough, you can totally define your own. These are just what Java ships with. For example, if you change `Function`‚Äôs return type to `boolean`, it becomes `Predicate`. We can absolutely create something like a `Function` that returns `Integer` and call it `IntFunction` or something (actually the JDK already provides it üòÇ).

Functional programming is the foundation, so in the **next post** I‚Äôll introduce the **vavr functional library** that I‚Äôve recently been obsessed with. It can make writing Java as smooth as Scala.



## References

1. [Side Effects in Functional Programming](https://stackoverflow.com/questions/38331690/side-effects-in-functional-programming)

2. [java8ÂÆûÊàò](https://book.douban.com/subject/26772632/)