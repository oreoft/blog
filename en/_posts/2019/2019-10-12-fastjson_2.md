---
category: java
excerpt: A Quick Overview
keywords: java, tools
lang: en
layout: post
title: Enhanced Serialization with FatJson
---

## Preface

Last time I talked about the basic usage of fastjson, but during serialization, we can’t always guarantee what properties we’re about to serialize. And sometimes we have some special requirements—for example, if a property is empty, should it be serialized or not? Of course, different businesses have different needs. FJ provides ways to satisfy these different requirements.

## The `SerializerFeature` enum

Last time we mentioned `JSON.toJSONString()`: pass in an `obj`, and it helps us serialize it into a JSON string. But you can also pass in another parameter: an enum value from `SerializerFeature`. For example: `JSON.toJSONString(stuList, SerializerFeature.PrettyFormat);`

![image-20210410171221578](https://mypicgogo.oss-cn-hangzhou.aliyuncs.com/tuchuang20210410171221.png)

<center>Its return value</center>



No one would dare put this string into production, right.... Anyway, that’s how you use it. Below are some of the more commonly used members in `SerializerFeature`:

```java
// Make the formatted string prettier by adding spaces, newlines, etc. (default is compressed to save space)
JSON.toJSONString(stuList,SerializerFeature.PrettyFormat);

// In the formatted string, wrap keys and values with single quotes (default is double quotes)
// [{'gender':'男','name':'小明'},{'name':'小刚'}]
JSON.toJSONString(stuList, SerializerFeature.UseSingleQuotes);

// If a field is null, still output it (default is not to output)
// [{"gender":"男","name":"小明"},{"gender":null,"name":"小刚"}]
JSON.toJSONString(stuList, SerializerFeature.WriteMapNullValue);

// If a list is empty, serialize it as [] instead of null (default is null)
JSON.toJSONString(stuList,SerializerFeature.WriteNullListAsEmpty);


// If a String field is null, output it as "" instead of null
JSON.toJSONString(stuList, SerializerFeature.WriteNullStringAsEmpty);


// If a numeric field is null, output it as 0 instead of null
JSON.toJSONString(stuList,SerializerFeature.WriteNullNumberAsZero);


// If a Boolean field is null, output it as false instead of null
JSON.toJSONString(stuList,SerializerFeature.WriteNullBooleanAsFalse);


// Write type information during serialization; by default it’s not written.
// After writing it, deserialization needs to handle it, and it also takes extra space.
JSON.toJSONString(stuList, SerializerFeature.WriteClassName);


// Make the formatted string prettier by adding spaces, newlines, etc.
JSON.toJSONString(stuList, SerializerFeature.SkipTransientField);
```

## Enhancing at the entity class level

Using enum features to enhance serialization is more common in `Map` scenarios—i.e., when you don’t want to create an entity class. But once a business scenario has reached the point where you *should* create an entity class, using these enum options frequently becomes tiring. FJ provides a one-and-done way to enhance serialization directly on the entity class.

```java
@Data
@Builder
@JSONType()
private static class Student {
  private String name;
  private String gender;
}
```

This `@JSONType` annotation lets you enhance serialization for all properties of this class. I’ll list a few commonly used options:

```java
@Data
@Builder
// Only include these fields during serialization
@JSONType(includes = {"name", "gender"})
private static class Student {
  private String name;
  private String gender;
}

@Data
@Builder
// Ignore these fields during serialization
@JSONType(ignores = {"name"})
private static class Student {
  private String name;
  private String gender;
}

@Data
@Builder
// Serialize in the order of the fields provided
@JSONType(orders = {"name", "gender"})
private static class Student {
  private String name;
  private String gender;
}

@Data
@Builder
// Choose the naming strategy for keys during serialization; default is CamelCase
// CamelCase studentName
// PascalCase student-name
// SnakeCase student_name
@JSONType(naming = PropertyNamingStrategy.CamelCase) 
private static class Student {
  private String name;
  private String gender;
}
```

## Annotations on entity properties

The above controls things at a more “macro” level. In practice, what’s used more often is the field-level annotation `JSONField()`, because it can be precise down to each field and is more controllable. Also, anything the other approaches can enhance can generally be done via field annotations too. Here are some commonly used options:

```java
@Data
@Builder
private static class Student {
  // Serialization order: the larger the number, the higher the priority.
  // If not set, fields are sorted alphabetically.
  @JSONField(ordinal = 0)
  private String name;
  private String gender;
}

@Data
@Builder
private static class Student {
  private String name;
  // Specify the name after serialization
  @JSONField(name = "sex")
  private String gender;
}

@Data
@Builder
private static class Student {
  private String name;
  private String gender;
  // Configure the date format during serialization and deserialization
  @JSONField(format = "yyyMMdd")
  private Date createTime;
}

@Data
@Builder
private static class Student {
  // Whether to serialize this field; default is true
  @JSONField(serialize=false)
  private String name;
  // Whether to deserialize this field; default is true
  @JSONField(deserialize=false)
  private String gender;
}
```

## Afterword

That’s it for some of FJ’s serialization enhancement methods. The most commonly used one is still the field-level annotation on entity classes. I strongly recommend taking a look at the source code of this annotation—what values it supports, and what each value means becomes immediately clear. Use it a couple of times and you’ll get the hang of it.